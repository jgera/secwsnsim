\subsection[Módulo de energia]{Módulo de energia} 
Com o módulo de energia pretende-se um componente que permita aferir os 
comportamentos de uma RSSF no que respeita ao consumo de energia. Partindo de um
estudo prévio de trabalhos publicados sobre o tema, foi possível chegar a um
conjunto de valores relacionados com os diferentes eventos que ocorrem
numa plataforma sensor durante a sua operação. Este estudo, permitiu, desde
logo, fazer uma abordagem sistémica para a definição do modelo de energia a
implementar.

Primariamente foi elaborada uma tabela que representa os eventos sobre os quais
se pretende medir os custos de energia durante a operação de um sensor. Esta
tabela procura enformar o estudo desta problemática resumindo a informação de
forma estruturada, permitindo uma visão geral do consumo de energia num
nó sensor. Assim, a tabela de eventos encontra-se organizada da seguinte forma:
Na primeira coluna surge a denominação do evento; Na segunda coluna  procura-se
caracterizar o evento quanto ao custo; Na terceira coluna indica-se a
parametrização de referência e por fim na quarta coluna apresenta-se o cálculo
do custo energético com base nas duas colunas anteriores.
\input{ pic_tabela_eventos} 

Observando a tabela, constata-se que a abordagem não foi conservadora comparada
com os modelos implementados em alguns simuladores de referência
\cite{powertossim}, uma vez que considera um conjunto de eventos bastante rico e
que consegue abarcar, consideravelmente todos os eventos mais relevantes e mais
frequentes que ocorrem num sensor que opere com requisitos de segurança. Alguns
autores separam o estudo destes eventos \cite{ESTUDOCRIPTO,ESTUDOCOMM}, por
forma a apenas analisarem uma parte dos custos energéticos, ora focando-se nos
custos dos mecanismos criptográficos ou de assinatura, ora focando-se nos
mecanismos de comunicação. Estas abordagens enriquecem os valores de
parametrização dos consumos energéticos em cada um dos casos, no entanto
considerando que existe uma relação efectiva entre a comunicação e os mecanismos
de segurança é interessante manter uma abordagem completa que nos permite
estabelecer desde logo uma comparação do overhead dos mecanismos de segurança no
processo de comunicação do protocolo.
\subsubsection[]{Algoritmo do modelo de energia}  
O algoritmo que se apresenta de seguida representa o modelo de consumo de
energia durante a operação do sensor tendo em conta o estado em que se encontra
em cada uma das operações. Note-se em particular o estado do
\textit{transciever} que pode obrigar a um consumo extra inerente ao facto de
ter que se ligar. Observe-se também a possibilidade de um sensor se encontrar
num estado de adormecimento, estado este que o impossibilita de participar no
protocolo de rede. 
\begin{algorithm}[H]
\eSe{estado==SLEEP}{
    Não detecta eventos (Aplicação não opera no simulador)
}{
    \eSe{detectado um $evento$}{
      processaMensagem();\\
      transmissao();
    }{ \emph{a operar em modo relay ou recepção}
        \eSe{recebeu $mensagem$}{
            \Se{transciever==OFF}{
                radio.toOn();\\
                bateria.consomeEnergia(transiçãoON->OFF,joule/acção) ;\\
            }
            radio.recebe\\
            bateria.consomeEnergia(transmissao,joule/byte) \\
            processaMensagem();\\
            transmissao();
        }{\emph{em relay}
          transmissao();
        }
    }
}

\caption{Algoritmo do modelo de energia}

\end{algorithm}
\begin{procedure}[H]
\eSe{transciever==ON}{
    radio.transmite\\
    bateria.consomeEnergia(transmissao,joule/byte) 
}{ \tcp{transciever==OFF}
    radio.toOn();\\
    bateria.consomeEnergia(transiçãoON->OFF,joule/acção) ;\\
    radio.transmite\\
    bateria.consomeEnergia(transmissao,joule/byte) \\
}
\caption{transmissao()}
\end{procedure}
\begin{procedure}[H]
\eSe{CPU.executarCifra()}{
    CPU.cifraMensagem()\\
    bateria.consomeEnergia(cifrar,joule/byte) 
}{  \eSe{CPU.executarDecifra()}{
        CPU.decifraMensagem()\\
        bateria.consomeEnergia(decifrar,joule/byte) 
    }{ \tcp{processamento normal}
        CPU.process();\\
        bateria.consomeEnergia(processar,joule/byte) ;
    }
}
\caption{processaMensagem()}
\end{procedure}


De entre os eventos apresentados poderemos dividir em dois grandes grupos os que
estão associados a estados de processamento e os que estão associados a estados
de comunicação. Tendo a segurança como ponto central, não se podem descurar os
eventos associados ao processamento, nomeadamente os que se referem a operações
criptográficas, quer estes sejam de assinatura, de cifra ou de integridade. No
entanto, a introdução destes mecanismos de segurança contribuem para um aumento
das comunicações, uma vez que, normalmente, é necessária informação complementar
para verificação de determinadas propriedades de segurança. Vejamos, por
exemplo, no protocolo INSENS\cite{INSENS} o facto de todas as mensagens terem um
MAC\cite{MAC} o que faz com que o \textit{payload} das mensagens aumente numa
razão considerável. 

Na caracterização do custo energético dos eventos, existem, fundamentalmente,
duas abordagens típicas \cite{energia,energia2}: uma que considera o tempo como
unidade de cálculo do consumo, por exemplo, calculando o tempo que
se passa a transmitir/receber, relacionando os consumos em \textit
{joule} com a largura de banda e o tempo de comunicação. Outra abordagem é a
caracterização com base no tamanho da mensagem calculado com base na energia
que se consome por byte operado. No modelo apresentado a decisão
passou por implementar a segunda abordagem uma vez que, tratando-se de tempos
que não correspondem ao comportamento real num sensor, a sua medição tornaria os
resultados mais afastados dos resultados reais. Ao se optar por uma medida
baseada em bytes, recorrendo à bibliografia de referência poder-se-à  sempre ter
os valores adequados aos tamanhos das mensagens, sem dependência do tempo de
do ambiente de simulação. 

A forma encontrada para permitir a modelação da energia e a sua implementação
de modo a ser o mais transparente possível para um programador, é a
implementação de um interface, que obriga à programação de uma operação de
execução e uma operação de devolução do numero de unidades consumidas. Em
relação ao número de unidades consumidas, esta operação terá
a semântica que se pretender implementar, tendo por base os valores de consumo
parametrizados no modelo de energia. Por exemplo, observe-se o bloco de código
seguinte referente à cifra de um \textit {payload} de uma mensagem.\\

\begin{FramedVerb}
1.	n.getCPU().executeEncryption(new EnergyConsumptionAction() {
2.	  public void execute() {
3.	    // execute Skipjack encryption on message payload 
4.		byte[] data= SkipjackEncrytion(node.getPayload(), myKey, myIV);
         ...
5.	   }
6.	   public int getNumberOfUnits() {
7.	     return node.getPayload().length; // return de size of payload encrypted
8.	   }
9.	});
\end{FramedVerb}
  

Na linha 7 é devolvido o tamanho do payload em bytes, uma vez que foram esses 
os dados que foram cifrados. No entanto o mesmo interface poderia ser usado para
devolver o numero de ciclos de execução do CPU, isto se os valores de energia
por ciclo usados para uma cifra Skypjack fossem parametrizados no modelo de
energia. Desta forma, tornou-se o modelo de energia flexível, primeiro dando
liberdade para definição dos valores de consumo com base na unidade de operação
desejada, e com recorrendo à implementação do interface, é possível afectar ao
componente respectivo a acção de consumo de energia executada. No exemplo,
pode-se observar na linha 4 que será do CPU a responsabilidade de consumo de
energia. Pois, caso se tratasse de uma transmissão ou recepção, seria um consumo
a ser imputado ao componente \textit {transciever}.

\subsubsection[]{Funcionamento do Módulo de Energia}
Depois de identificados os eventos, definidos os valores de consumo de energia 
para cada um e a formula de cálculo, foi introduzido uma operação no componente
Batery para o consumo de cada um destes eventos. Estas operações contabilizam o
consumo consultando a parametrização de referência do modelo de energia. Cada
evento tem uma etiqueta, que é usada para o registo do consumo e do valor
consumido em cada instante em cada um dos nós envolvidos na simulação. Todos os
eventos de consumo são registados num repositório para análise gráfica no
âmbito da simulação.
O funcionamento do módulo de energia resulta da interacção de diversos
componentes do simulador, o diagrama que se apresenta a seguir procura
representar esta interacção para o exemplo de transmissão de uma mensagem.
\input{pic_DS_TransmissionPower} 
Observando o código é visível a expressividade para a exploração do modelo de 
energia e de forma transparente. É necessário parametrizar os valores do modelo
de energia e indicar as unidades de consumo.\\
\begin{FramedVerb}
if (isChannelFree(noiseStrength)) {
	\\ start transmitting
    stransmitting = true;
    final Node node = getNode();
    getNode().getTransceiver().executeTransmission(new EnergyConsumptionAction() {
	
     DefaultMessage m = (DefaultMessage) node.getMessage();
     public void execute() {
       transmitMessage();
     }
     public int getNumberOfUnits() {
	    return m.size();
	}
  });
}
\end{FramedVerb}
\\Ao nível do componente, no caso o Transciever, para a contabilização do 
consumo de transmissão, o que se verifica é o seguinte:\\
\begin{FramedVerb}
public void executeTransmission(EnergyConsumptionAction action  ){
  switchON(); \\ transição aleatória de estado 
  action.execute(); \\ execução da acção de consumo
  int rate= action.getNumberOfUnits(); \\ contabilização das unidades
  \\ consumo de energia correspondente
  getNode().getBateryEnergy().consumeTransmission(rate);
  switchOFF();
}
\end{FramedVerb}
\\
Ao reutilizar o modelo MAC implementado no simulador JProwler e este não 
prevendo as mudanças de estado inerentes ao funcionamento de um \textit {mote},
foi implementado um mecanismo aleatório para a transição de estado dos
componentes dos sensores. É possível, desta forma, simular a activação
(transição do estado desligado para o ligado) de um componente, por exemplo o
\textit{Transciever}, para iniciar a transmissão . Assim consegue-se considerar
os custos referentes à activação dos componentes depois de estes entrarem em
modos de consumo reduzido. O desenho dos sensores organizado por camadas
possibilita a implementação de protocolos MAC para diferentes âmbitos,
nomeadamente a implementação os protocolos S-MAC, B-MAC, Z-MAC.

\subsubsection[]{Obtenção de resultados}

Para a medição de energia foi criado um sistema central de
recolha de eventos de consumo de energia, que respeitam a estrutura apresentada
na figura seguinte.

FIGURA E LEGENDA

Com esta estrutura de dados é possível obter um conjunto de dados interessantes
relacionados com a energia, reveladores de tendências e comportamentos de
operação da rede. A existência deste componente agregador da informação de
consumo de energia, embora não contenha um conjunto de dados exaustivo, fornece,
por correlação de dados, vários tipos de resultados. Na tabela seguinte
apresentam-se alguns destes resultados que se podem extrair referentes ao
consumo de energia numa RSSF.
\begin{description}
 \item[Consumo por nó] Permite analisar os consumos por nós permitindo
estabelecer malhas de consumo energia por localização dos nós na rede (por
exemplo, observando se os sensores próximo de uma estação base, consomem mais
energia);
\item[Consumo por evento energético] Permite analisar/observar quais os eventos
que consomem mais energia na operação da rede, ainda que se saiba de antemão
que os relacionados com a comunicação são os mais dispendiosos; 
\item[Consumo por fase de protocolo] Permite separar o consumo em cada uma das
fases que se tenham definido na implementação do protocolo, contribuindo para a
identificação de anomalias ou correcção na especificação de determinado
protocolo;
\item[Consumo temporal] Uma vez que associado a cada evento, se regista a
selo temporal em que ocorre, pode-se extrair dados relevantes quanto à evolução
do consumo energético durante a operação.
\end{description}

Com este modelo estão criadas as condições para obter uma análise mais rica
referente ao consumo de energia de uma RSSF, sabendo que este é um recurso
escasso e muitas vezes de difícil reposição. No que respeita à implementação do
desde componente colector de informação de energia, existem três
implementações distintas: 1) Em memória e que se encontra carregada durante
o tempo da simulação; 2) Escrita para ficheiro raw usando as primitivas
\textit{DataStream} do Java; 3) Escrita para base de dados (no caso MySQL). As
duas últimas implementações permitem a análise em sede de pós-processamento.






 